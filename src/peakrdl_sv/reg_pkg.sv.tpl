// Copyright Shareef Jalloq
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv

<%
  lname = block.inst_name.lower()
  ublock = block.inst_name.upper()

  addr_width = block.addrwidth
  data_width = block.accesswidth
  registers  = block.get_registers()
  num_regs   = len(registers)
  max_regs_char = len("{}".format(num_regs-1))

%>\
package ${lname}_reg_pkg;

  // Address width
  parameter int BlockAw = ${block.addrwidth};


  % for r in registers:
  // ${r.path}
  typedef struct packed {
  % if len(r) == 1:
    logic ${sv_bitarray(r[0])}q;
    % if r[0].swmod:
    logic qe;
    % endif
  % else:
    % for f in r:
    struct packed {
      logic ${sv_bitarray(f)}q;
      % if f.swmod:
      logic qe;
      % endif
    } ${f.name};
    % endfor
  % endif
  } ${r.owning_addrmap.inst_name}_reg2hw_${r.path}_t;

  % endfor\

  % for r in registers:
  // ${r.path}
  typedef struct packed {
    % if len(r) == 1:
    logic ${sv_bitarray(r[0])}d;
    logic de;
    % else:
    % for f in r:
    struct packed {
      logic ${sv_bitarray(f)}d;
      logic de;
    } ${f.name};
    % endfor
    % endif
  } ${hw2reg_t_gen(r)};

  % endfor

  // Register -> HW
  typedef struct packed {
  % for r in registers:
    ${reg2hw_t_gen(r)} ${r.path};
  % endfor 
  } ${lname}_reg2hw_t;

  // HW -> Register
  typedef struct packed {
  % for r in registers:
    ${hw2reg_t_gen(r)} ${r.path};
  % endfor 
  } ${lname}_hw2reg_t;

  // Register address offsets
  % for r in registers:
<%
    value = f"{addr_width}'h{r.absolute_address:x}"
    param = f"{ublock}_{r.path.upper()}_OFFSET"
%>\
  parameter logic [BlockAw-1:0] ${param} = ${value};
  % endfor

endpackage
<%def name="hw2reg_t_gen(reg)" filter="trim">\
${reg.owning_addrmap.inst_name}_hw2reg_${reg.path}_t
</%def>\
<%def name="reg2hw_t_gen(reg)" filter="trim">\
${reg.owning_addrmap.inst_name}_reg2hw_${reg.path}_t
</%def>\
<%def name="sv_bitarray(field)" filter="trim">\
% if field.width > 1:
[${field.width-1}:0]
% endif
</%def>
