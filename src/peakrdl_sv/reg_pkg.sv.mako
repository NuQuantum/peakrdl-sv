// Copyright Nu Quantum Ltd
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv

<%
  lname = block.inst_name.lower()
  ublock = block.inst_name.upper()

  addr_width = block.addrwidth
  data_width = block.accesswidth
  registers  = block.get_registers()

%>\
package ${lname}_reg_pkg;

  // Address width
  parameter int BlockAw = ${block.addrwidth};

  %if block.has_reg2hw:
  % for r in registers:
  ## Only create the reg2hw struct if the register is present in it.
  % if r.present_in_reg2hw:
  // ${r.path()}
  typedef struct packed {
  % if len(r) == 1:
    % if r[0].implements_storage:
    logic ${sv_bitarray(r[0])}q;
    % endif
    % if r[0].needs_qe:
    logic qe;
    % endif
    % if r[0].needs_qre:
    logic re;
    % endif
  % else:
    ## Only create the substruct if the field is present in reg2hw struct
    % for f in filter(lambda f : f.present_in_reg2hw, reversed(r)):
    struct packed {
      % if f.implements_storage:
      logic ${sv_bitarray(f)}q;
      % endif
      % if f.needs_qe:
      logic qe;
      % endif
      % if f.needs_qre:
      logic re;
      % endif
    } ${f.name.lower()};
    % endfor
  % endif
  } ${reg2hw_t_gen(r)};
  % endif

  % endfor
  % endif

  % for r in registers:
  // ${r.path()}
  typedef struct packed {
    % if len(r) == 1:
    logic ${sv_bitarray(r[0])} d;
    % if r[0].implements_storage:
    logic de;
    % endif
    % else:
    % for f in reversed(r):
    struct packed {
      logic ${sv_bitarray(f)} d;
    % if f.implements_storage:
      logic de;
    % endif
    } ${f.name.lower()};
    % endfor
    % endif
  } ${hw2reg_t_gen(r)};

  % endfor \

  ## Only create the reg2hw if there is atleast one register requiring q, qe or qre signals.
  %if block.has_reg2hw:
  // Register -> HW
  typedef struct packed {
<%
  tmp = 0
  nbits = sum([f.get_reg2hw_struct_bits() for r in registers for f in r])
%>\
  % for r in filter(lambda reg: reg.present_in_reg2hw, registers):
<%
  reg_bits = sum([f.get_reg2hw_struct_bits() for f in r])
  msb = nbits - tmp - 1
  lsb = msb - reg_bits + 1
  tmp += reg_bits
  comment = f"// {msb}:{lsb}"
  lsb = msb + 1
%>\
    ${reg2hw_t_gen(r)} ${r.path().lower()}; ${comment}
  % endfor
  } ${lname}_reg2hw_t;
  % endif

  ## Only create the hw2reg if there is atleast one register that is hw_writable.
  % if block.has_hw2reg:
  // HW -> Register
  typedef struct packed {
<%
  tmp = 0
  nbits = sum([f.get_hw2reg_struct_bits() for r in registers for f in r])
%>\
  % for r in filter(lambda reg: reg.present_in_hw2reg, registers):
<%
  reg_bits = sum([f.get_hw2reg_struct_bits() for f in r])
  msb = nbits - tmp - 1
  lsb = msb - reg_bits + 1
  tmp += reg_bits
  comment = f"// {msb}:{lsb}"
  lsb = msb + 1
%>\
    ${hw2reg_t_gen(r)} ${r.path().lower()}; ${comment}
  % endfor
  } ${lname}_hw2reg_t;
  % endif

  // Register address offsets
  % for r in registers:
<%
    if r.is_wide:
      values = []
      params = []
      for i in range(r.subregs):
        values.append(f"{addr_width}'h{r.absolute_address+(i*r.addressincr):X}")
        params.append(f"{ublock}_{r.path().upper()}_{i}_OFFSET")
    else:
      values = [f"{addr_width}'h{r.absolute_address:X}"]
      params = [f"{ublock}_{r.path().upper()}_OFFSET"]
%>\
  % for p,v in zip(params, values):
  parameter logic [BlockAw-1:0] ${p} = ${v};
  % endfor
  % endfor

endpackage
<%def name="hw2reg_t_gen(reg)" filter="trim">\
${reg.owning_addrmap.inst_name.lower()}_hw2reg_${reg.path().lower()}_t
</%def>\
<%def name="reg2hw_t_gen(reg)" filter="trim">\
${reg.owning_addrmap.inst_name.lower()}_reg2hw_${reg.path().lower()}_t
</%def>\
<%def name="sv_bitarray(field)" filter="trim">\
% if field.width > 1:
[${field.width-1}:0]
% endif
</%def>
